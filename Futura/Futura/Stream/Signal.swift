/* Copyright 2018 Miquido

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License. */

/// Signal is an object that can be used to pass, transform and observe
/// continous stream of values and/or errors generated by some source.
/// Using handlers and transformations allows to easily manipulate
/// and inspect flow of data. Signal also allows to manage execution
/// by selecting threads manually if needed.
/// It does not use any cache or initial value mechanism so all tokens
/// passed before observation will never occour.
public class Signal<Value> {
    internal typealias Token = Either<Error, Value>
    internal typealias Subscriber = (Either<Error?, Token>) -> Void

    private var subscriptionID: Subscription.ID = 0
    private let privateCollector: SubscriptionCollector = .init()

    internal let lock: RecursiveLock = .init()
    internal var subscribers: [(id: Subscription.ID, subscriber: Subscriber)] = .init()
    internal weak var collector: SubscriptionCollector?
    internal var isFinished: Bool = false
    internal var isUnsubscribing: Bool = false

    internal init(collector: SubscriptionCollector?) {
        self.collector = collector
    }

    internal func subscribe(_ subscriber: @escaping Subscriber) -> Subscription? {
        return lock.synchronized {
            guard !isFinished else { return nil }
            let id = subscriptionID.next()
            subscribers.append((id: id, subscriber: subscriber))
            return Subscription.init { [weak self] in
                guard let self = self else { return }
                self.lock.synchronized {
                    self.isUnsubscribing = true
                    if let idx = self.subscribers.firstIndex(where: { $0.id == id }) {
                        self.subscribers.remove(at: idx)
                    } else { /* do nothing */ }
                    self.isUnsubscribing = false
                }
            }
        }
    }

    internal func broadcast(_ token: Token) {
        lock.synchronized {
            guard !isSuspended else { return }
            subscribers.forEach { $0.1(.right(token)) }
        }
    }

    internal func finish(_ reason: Error? = nil) {
        lock.synchronized {
            guard !isSuspended else { return }
            #warning("TODO: this suspended may prevent braodcasting finish - to check")
            subscribers.forEach { $0.1(.left(reason)) }
            isFinished = true
            var sub = subscribers
            // cache until end of scope to prevent deallocation of subscribers while making changes in subscribers dictionary - prevents crash
            subscribers = .init()
            sub.removeAll() // only to silence warning about unused value `sub`
            #warning("TODO: to check performance of removeAll")
        }
    }

    internal func collect(_ subscribtion: Subscription?) {
        guard let subscribtion = subscribtion else { return }
        if let collector = collector {
            collector.collect(subscribtion)
        } else {
            privateCollector.collect(subscribtion)
        }
    }

    // prevents broadcasting if internal state not allows this
    // i.e. in the middle of removing subscription
    // prevents a lot of crashes...
    internal var isSuspended: Bool {
        return isUnsubscribing || !(collector?.isActive ?? true) || !privateCollector.isActive
    }

    deinit { finish() }
}

public extension Signal {
    
    /// Handler used to observe values passed through this Signal instance.
    ///
    /// - Parameter observer: Handler called every time Signal gets value.
    /// - Returns: Same Signal instance for eventual further chaining.
    @discardableResult
    func values(_ observer: @escaping (Value) -> Void) -> Signal {
        collect(subscribe { event in
            guard case let .right(.right(value)) = event else { return }
            observer(value)
        })
        return self
    }

    /// Handler used to observe errors passed through this Signal instance.
    ///
    /// - Parameter observer: Handler called every time Signal gets error.
    /// - Returns: Same Signal instance for eventual further chaining.
    @discardableResult
    func failures(_ observer: @escaping (Error) -> Void) -> Signal {
        collect(subscribe { event in
            guard case let .right(.left(value)) = event else { return }
            observer(value)
        })
        return self
    }

    #warning("TODO: add tokens handler - either value or error without reference")

    /// Handler used to observe finishing of this Signal by ending (without error).
    ///
    /// - Parameter observer: Handler called when Signal ends.
    /// - Returns: Same Signal instance for eventual further chaining.
    @discardableResult
    func ended(_ observer: @escaping () -> Void) -> Signal {
        #warning("Since this method waits for completion and can be called only once shouldn't it be called if Signal already finished?")
        collect(subscribe { event in
            guard case .left(.none) = event else { return }
            observer()
        })
        return self
    }

    /// Handler used to observe finishing of this Signal by termination (with error).
    ///
    /// - Parameter observer: Handler called when Signal terminates.
    /// - Returns: Same Signal instance for eventual further chaining.
    @discardableResult
    func terminated(_ observer: @escaping (Error) -> Void) -> Signal {
        #warning("Since this method waits for completion and can be called only once shouldn't it be called if Signal already finished?")
        collect(subscribe { event in
            guard case let .left(.some(reason)) = event else { return }
            observer(reason)
        })
        return self
    }

    /// Handler used to observe finishing of this Signal either by ending or termination
    /// (with or without error).
    ///
    /// - Parameter observer: Handler called when Signal finishes.
    /// - Returns: Same Signal instance for eventual further chaining.
    @discardableResult
    func finished(_ observer: @escaping () -> Void) -> Signal {
        #warning("Since this method waits for completion and can be called only once shouldn't it be called if Signal already finished?")
        collect(subscribe { event in
            guard case .left = event else { return }
            observer()
        })
        return self
    }
}
